# WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
# This file was auto-generated by the Shine protocol compiler.
# DO NOT EDIT THIS FILE. The compiler will overwrite all your hard work.

# Messages
{% for message in messages %}
class {{ message.name_ }}:
  def __init__(self, *args):
    # Verify that we've passed in the correct number of fields or none.
    assert(len(args) == 0 or len(args) == {{ message.num_fields_ }})

    # TOOD(jmcgill): Work out how to iniailize fields.
    self.fields = [
      {% for field in message.fields_ %}
        {% if field.repeated_ %}
          [],
        {% else %}
          0,
        {% endif %}
      {% endfor %}
    ]
    
    i = 0
    for arg in args:
      self.fields[i] = arg
      i += 1

    self.total_fields = {{ message.num_fields_ }}
    self.types_ = [
      {% for field in message.fields_ %}
        shine_parser.FieldTypes.{{ field.type_ }},
      {% endfor %}
    ];  
  
    self.repeated_ = [
      {% for field in message.fields_ %}
       {{ field.repeated_ }},
      {% endfor %}
    ];

  def num_fields(self):
    return self.total_fields
  
  def field(self, index):
    return self.types_[index]

  def repeated(self, index):
    return self.repeated_[index]

  def value(self, index):
    return self.fields[index]

  def set_value(self, index, value):
    self.fields[index] = value

  def size(self, index):
    return len(self.fields[index])

  {% for field in message.fields_ %} 
  {% if field.repeated_ %}
  def set_{{ field.name_ }}(self, index, value):
    if len(self.fields[{{ field.index_ }}]) <= index:
      self.fields[{{ field.index_ }}].append([0] * (index - len(self.fields[{{ field.index_ }}]) + 1))

    self.fields[{{ field.index_ }}][index] = value

  def get_{{ field.name_ }}(self, index):
    if (index < len(self.fields[{{ field.index_ }}])):
      return self.fields[{{ field.index_ }}][index] 
    return 0

  def add_{{ field.name_ }}(self, value):
    self.fields[{{ field.index_ }}].append(value)

  def {{ field.name_ }}_size(self):
    return len(self.fields[{{ field.index_ }}])

  {% else %}
  def set_{{ field.name_ }}(self, value):
    self.fields[{{ field.index_ }}] = value
  {% endif %}
  def get_{{ field.name_ }}(self):
    return self.fields[{{ field.index_ }}]
  {% endfor %}

  # TODO(jmcgill): Repeated fields in python.
{% endfor %}

# RPCs.
{% for rpc in rpcs %}
def Remote_{{ rpc.name_ }}(service, input):
  # Initiate the context in the service.
  service.input_ = input

  {% if rpc.output_ %}
  service.output_ = {{ rpc.output_ }}()
  {% else %}
  service.output_ = None
  {% endif %}
  
  # Call the RPC
  service.CallRPC({{ rpc.index_ }})

  # Send all scalar values
  # In the future we may only send early values and dynamically request others
  # It doesn't appear to be worth maintaining a cache of recent values on the
  # AVR. The CPU and memory cost is too high.
  # max_index = self.GetEarlyScalarValues(input)
  # self.transport_.SendByte(max_index)
  # for i in range(0, max_index):
  #  self.SendFieldValue(input.field(i), i, input.value(i))
    
  # Determine how many fields we'll be sending
  count = 0 
  for i in range(0, input.num_fields()):
  #  if not input.repeated(i):
    # Repeated fields now count since we send their size.
    count += 1
  service.transport_.SendByte(count)

  # Send each of these fields
  for i in range(0, input.num_fields()):
    if not input.repeated(i):
      service.SendFieldValue(input.field(i), i, input.value(i))
    else:
      service.SendFieldSize(i, input.size(i))
  
  # Loop until the RPC is complete.
  while (service.ProcessCommands()):
    pass
 
  # Return output, if built up.
  return service.output_
{% endfor %}
